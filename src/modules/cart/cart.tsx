/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import {
    IAddToOrderTemplateDialogResources,
    IDuplicateItemsWhenAddingToOrderTemplateDialogResources,
    IItemAddedToOrderTemplateDialogResources,
    ILinesAddedToOrderTemplateDialogResources,
    IOrderTemplateNameDialogResources,
    IWishlistActionSuccessResult,
    PromoCodeComponent,
    SaveCartToOrderTemplateComponent
} from '@msdyn365-commerce/components';
import MsDyn365, { getCatalogId, getUrlSync, IImageSettings, isChannelTypeB2B } from '@msdyn365-commerce/core';
import { ICartActionResult, ICartState } from '@msdyn365-commerce/global-state';
import { AsyncResult, CartLine, CartLineValidationResultsByLineId, LineValidationResult } from '@msdyn365-commerce/retail-proxy';
import { FeatureState, ProductDeliveryOptions, ReleasedProductType } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { cartLineQuantityUpdatedAsync, validateCartAsync } from '@msdyn365-commerce-modules/cart-utilities';
import { IInvoiceSummaryLines, InvoiceSummary } from '@msdyn365-commerce-modules/invoice-payment-summary';
import { IOrderSummaryLines, OrderSummary } from '@msdyn365-commerce-modules/order-summary-utilities';
import {
    ActiveCartProductsInput,
    ArrayExtensions,
    getActiveCartProductsAction,
    ICartLineInventoryValidationResult,
    ObjectExtensions,
    validateCartLinesInventory,
    ProductPickUpOptionsForCartLineItems,
    validateCatalogId
} from '@msdyn365-commerce-modules/retail-actions';
import {
    Alert,
    Button,
    getPayloadObject,
    getTelemetryAttributes,
    getTelemetryObject,
    INodeProps,
    IPayLoad,
    ITelemetryContent,
    TelemetryConstant,
    Waiting,
    updateMaxQuantityForCartLineItem,
    urlCheck
} from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import React from 'react';
import { getPickUpOptionsForCartLineItems } from './actions/get-pickup-options-for-cartlines';

import { ICartData } from './cart.data';
import { ICartProps, ICartResources } from './cart.props.autogenerated';
import { CartLineGroupItems } from './components/cart-line-groups';
import { CartLineItems, ICartlinesViewProps } from './components/cart-line-items';
import { cartPromotions, ICartLineItemViewProps } from './components/cart-line-items-promotion';
import { getPromotionData, IPromotionData } from './utils/get-promotion-in-cart';

/**
 * Cart view props interface.
 */
export interface ICartViewProps extends ICartProps<ICartData> {
    className: string;
    title?: React.ReactNode;
    CartlinesWrapper: INodeProps;
    cartlines?: ICartlinesViewProps[];
    cartLinesGroup?: ICartlinesViewProps[][];
    cart: ICartState | undefined;
    orderSummaryHeading: React.ReactNode;
    orderSummaryLineitems?: IOrderSummaryLines;
    invoiceSummaryLineitems?: IInvoiceSummaryLines;
    OrderSummaryWrapper: INodeProps;
    OrderSummaryItems: INodeProps;
    OrderSummaryErrors?: IOrderSummaryErrors;
    checkoutAsGuestButton: React.ReactNode;
    checkoutAsSignInUserButton: React.ReactNode;
    storeSelector?: React.ReactNode;
    expressCheckoutButton?: React.ReactNode[];
    ExpressCheckoutSectionWrapper: INodeProps;
    backToShoppingButton: React.ReactNode;
    waitingComponent: React.ReactNode;
    promotionOptions?: ICartLineItemViewProps;
    promoCode: React.ReactNode;
    cartLoadingStatus: string;
    cartDataResult: boolean;
    multiplePickUpEnabled?: boolean;
    createTemplateFromCartButton: React.ReactNode;
    telemetryContent?: ITelemetryContent;
    checkoutBlockedDueToUnavailableFunds?: React.ReactNode;
    removeItemClickHandler(cartlineToRemove: CartLine): void;
    moveToWishlistSuccessHandler(result: IWishlistActionSuccessResult, cartlineId: CartLine): void;
}

/**
 * Order summary errors interface.
 */
export interface IOrderSummaryErrors {
    Wrapper: INodeProps;
    header: React.ReactNode;
    errors: React.ReactNode[];
}

/**
 * Cart component state interface.
 */
interface ICartComponentState {
    showPromotionDialog: boolean;
    cartlinesErrors: CartLineValidationResultsByLineId;
    promotionData: IPromotionData;
    isCartValid: boolean;
    productPickUpOptions?: ProductDeliveryOptions[];
}

/**
 * Cart component.
 * @extends {React.PureComponent<ICartProps<ICartData>>}
 */
@observer
class Cart extends React.Component<ICartProps<ICartData>> {
    public state: ICartComponentState;

    private readonly telemetryContent: ITelemetryContent;

    private readonly payLoad: IPayLoad;

    private isQuantityLimitsFeatureEnabled: boolean = false;

    private _isMounted: boolean = false;

    private readonly promotionPopupId: string = 'cart-promotion-popup';

    public constructor(props: ICartProps<ICartData>) {
        super(props);
        this.telemetryContent = getTelemetryObject(
            this.props.context.request.telemetryPageName!,
            this.props.friendlyName,
            this.props.telemetry
        );
        this.payLoad = getPayloadObject('click', this.telemetryContent, '');
        this.promotionLinkClick = this.promotionLinkClick.bind(this);
        this.promotionCloseButtonclick = this.promotionCloseButtonclick.bind(this);

        this.state = {
            showPromotionDialog: false,
            promotionData: {},
            isCartValid: true,
            productPickUpOptions: undefined,
            cartlinesErrors: {}
        };
    }

    /**
     * Component did mount function.
     */
    public async componentDidMount(): Promise<void> {
        this._isMounted = true;
        const {
            config,
            context: { actionContext }
        } = this.props;

        this.isQuantityLimitsFeatureEnabled =
            (await this.getOrderQuantityLimitsFeatureFlag()) || (await this._isChannelLimitsFeatureEnabled());
        if (this.isQuantityLimitsFeatureEnabled) {
            await this.validateCart();
        }

        if (config.showAvailablePromotions) {
            if (this._isMounted && this.props.data.cart.result?.cart.CartLines) {
                this.setState({ promotionData: await getPromotionData(actionContext) });
            }

            reaction(
                () => this.props.data.cart.result?.cart.CartLines,
                async () => {
                    if (this._isMounted) {
                        this.setState({ promotionData: await getPromotionData(actionContext) });
                    }
                }
            );
        }
        reaction(
            () => this.props.data.cart.result?.cart.CartLines,
            async () => {
                if (this._isMounted) {
                    const input = new ProductPickUpOptionsForCartLineItems(actionContext.requestContext.apiSettings);
                    this.setState({ productPickUpOptions: await getPickUpOptionsForCartLineItems(input, actionContext) });
                }
            }
        );
    }

    /**
     * Component will unmount function.
     */
    public componentWillUnmount(): void {
        this._isMounted = false;
    }

    /**
     * Should component update function.
     * @param nextProps - Next props.
     * @param nextState - Next state.
     * @returns True if component should update, false otherwise.
     */
    public shouldComponentUpdate(nextProps: ICartProps<ICartData>, nextState: ICartComponentState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    /* eslint-disable complexity -- Disabling complexity for render method */
    public render(): JSX.Element | null {
        const {
            data: {
                cart: { result: cart },
                products: { result: products }
            },
            context: {
                request: {
                    user: { isAuthenticated, signInUrl }
                }
            },
            resources
        } = this.props;

        const guestCheckoutUrl = getUrlSync('checkout', this.props.context.actionContext) || '';
        const backToShoppingUrl = getUrlSync('home', this.props.context.actionContext) || '';
        const checkoutURL = this.getCheckoutURL(isAuthenticated, guestCheckoutUrl, signInUrl || '');
        const isCartEmpty = cart && cart.cart.CartLines && cart.cart.CartLines.length === 0;
        const cartLines = this._getCartLines();
        const emailDeliveryModeCode = this.props.context.request.channel?.EmailDeliveryModeCode;
        const validInventoryAcrossCartLines = validateCartLinesInventory(
            cart?.cart.CartLines ?? [],
            this.props.data.productAvailabilites.result ?? [],
            this.props.context.actionContext,
            products ?? [],
            emailDeliveryModeCode
        );

        const hasError =
            !validInventoryAcrossCartLines?.isValid ||
            (!validInventoryAcrossCartLines && !this.state.isCartValid) ||
            (cartLines ? cartLines.some(cartline => cartline.hasError) : false);
        const RetailMultiplePickupFeatureState = this.props.data.featureState.result?.find(
            featureState => featureState.Name === 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature'
        );
        const multiplePickUpEnabled = RetailMultiplePickupFeatureState?.IsEnabled;
        const channelMultipleCatalogsFeature = 'Dynamics.AX.Application.ChannelMultipleCatalogsFeature';
        const { featureState } = this.props.data;
        const isMultipleCatalogsFeatureEnabled =
            featureState.result?.find((item: FeatureState) => item.Name === channelMultipleCatalogsFeature)?.IsEnabled || false;
        const currentCatalogId = getCatalogId(this.props.context.request);
        validateCatalogId(currentCatalogId);
        const cartLinesGroup = cart?.hasInvoiceLine || multiplePickUpEnabled ? this.getCartLinesGroup() : null;
        this.payLoad.contentAction.etext = TelemetryConstant.Checkout;
        const checkoutBySignInAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);
        this.payLoad.contentAction.etext = TelemetryConstant.GuestCheckout;
        const checkoutByGuestAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);
        this.payLoad.contentAction.etext = TelemetryConstant.BackToShopping;
        const backtoShoppingAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);

        // If there's inventory issues across multiple cart lines then update the error and display as part of the order summary
        if (validInventoryAcrossCartLines && !validInventoryAcrossCartLines.isValid) {
            if (multiplePickUpEnabled && cartLinesGroup !== null) {
                for (const cartLineGroup of cartLinesGroup) {
                    this._updateCartLineErrorForInvalidInventory(cartLineGroup, validInventoryAcrossCartLines);
                }
            }

            this._updateCartLineErrorForInvalidInventory(cartLines, validInventoryAcrossCartLines);
        }

        const viewProps = {
            ...this.props,
            className: classnames('ms-cart'),
            title: <h1 className='msc-cart__heading'>{resources.cartTitle}</h1>,
            cart: this.props.data.cart.result,
            CartlinesWrapper: { className: 'msc-cartline-wraper' },
            OrderSummaryWrapper: { className: cart?.hasInvoiceLine ? 'msc-invoice-summary-wrapper' : 'msc-order-summary-wrapper' },
            OrderSummaryItems: { className: cart?.hasInvoiceLine ? 'msc-invoice-summary__items' : 'msc-order-summary__items' },
            cartlines: cartLines,
            cartLinesGroup,
            promoCode: this._getPromoCode(),
            promotionOptions: this._getPromotions(),
            context: this.props.context,
            typeName: this.props.typeName,
            telemetry: this.props.telemetry,
            id: this.props.id,
            multiplePickUpEnabled,
            removePromoAriaLabelFormat: resources.removePromoAriaLabelFormat,
            orderSummaryHeading: ArrayExtensions.hasElements(cart?.cart.CartLines) ? (
                cart?.hasInvoiceLine ? (
                    <h2 className='msc-invoice-summary__heading'>{resources.invoiceSummaryTitle}</h2>
                ) : (
                    <h2 className='msc-order-summary__heading'>{resources.orderSummaryTitle}</h2>
                )
            ) : null,
            orderSummaryLineitems: this._getOrderSummaryLineItems(),
            invoiceSummaryLineitems: this._getInvoiceSummaryLineItems(),
            checkoutAsSignInUserButton: !isCartEmpty ? (
                <Button
                    disabled={hasError}
                    className='msc-cart__btn-checkout'
                    href={checkoutURL}
                    title={resources.checkoutButtonTitle}
                    {...checkoutBySignInAttributes}
                >
                    {resources.checkoutButtonTitle}
                </Button>
            ) : null,
            checkoutAsGuestButton:
                !isCartEmpty && !isAuthenticated && this.props.config.showGuestCheckoutButton ? (
                    <Button
                        disabled={hasError}
                        className='msc-cart__btn-guestcheckout'
                        href={guestCheckoutUrl}
                        title={resources.guestCheckoutButtonTitle}
                        {...checkoutByGuestAttributes}
                    >
                        {resources.guestCheckoutButtonTitle}
                    </Button>
                ) : null,
            expressCheckoutButton: !isCartEmpty ? this.props.slots.paymentExpress : null,
            ExpressCheckoutSectionWrapper: { className: 'msc-express-payment-container-in-cart-page' },
            backToShoppingButton: (
                <Button
                    className='msc-cart__btn-backtoshopping'
                    {...backtoShoppingAttributes}
                    href={backToShoppingUrl}
                    title={resources.backToShoppingButtonTitle}
                >
                    {resources.backToShoppingButtonTitle}
                </Button>
            ),
            createTemplateFromCartButton:
                this._displayAddCartToTemplate() && products ? (
                    <SaveCartToOrderTemplateComponent
                        addToOrderTemplateDialogResources={this._generateAddToOrderTemplateDialogResources(resources)}
                        createOrderTemplateDialogResources={this._generateOrderTemplateNameDialogResources(resources)}
                        linesAddedToOrderTemplateDialogResources={this._generateLinesAddedToOrderTemplateDialogResources(resources)}
                        duplicateItemsWhenAddingToOrderTemplateDialogResources={this._generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(
                            resources
                        )}
                        createOrderTemplateFromCartButton={resources.createOrderTemplateFromCartButton}
                        createOrderTemplateFromCartButtonTooltip={resources.createOrderTemplateFromCartButtonTooltip}
                        context={this.props.context}
                        id={this.props.id}
                        typeName={this.props.typeName}
                        isMultipleCatalogFeatureEnabledInHq={isMultipleCatalogsFeatureEnabled || false}
                        catalogId={currentCatalogId}
                        data={{
                            orderTemplates: this.props.data.orderTemplates.result!,
                            cartLines: this.props.data.cart.result!.cart.CartLines!,
                            customerInformation: this.props.data.customerInformation.result
                        }}
                    />
                ) : null,
            checkoutBlockedDueToUnavailableFunds: null,
            storeSelector:
                this.props.slots.storeSelector && this.props.slots.storeSelector.length > 0 ? this.props.slots.storeSelector[0] : null,
            removeItemClickHandler: this.removeItemFromCartHandler,
            moveToWishlistSuccessHandler: this.moveToWishlistSuccessHandler,
            waitingComponent: <Waiting className='msc-waiting-circular msc-waiting-lg' />,
            cartLoadingStatus: this.props.data.cart.status === 'FAILED' ? this.props.resources.cartLoadingErrorMessage : null,
            cartDataResult: this.props.data.cart.result && this.props.data.cart.result.isEmpty,
            OrderSummaryErrors: this._getOrderSummaryErrors(cartLines),
            telemetryContent: this.telemetryContent
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }
    /* eslint-enable complexity -- Disabling complexity for render method */

    /**
     * Promotion click event handler.
     * @param event - The mouse event.
     */
    private readonly promotionLinkClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        this.setState({
            showPromotionDialog: !this.state.showPromotionDialog
        });
    };

    /**
     * Promotion close button click.
     */
    private readonly promotionCloseButtonclick = () => {
        this._hidePromotionDialog();
    };

    /**
     * Hide promotion dialog.
     */
    private _hidePromotionDialog(): void {
        this.setState({
            showPromotionDialog: false
        });
    }

    /**
     * Display add to cart template.
     * @returns True if should display, false otherwise.
     */
    private _displayAddCartToTemplate(): boolean {
        const cart = this.props.data.cart?.result;
        if (ObjectExtensions.isNullOrUndefined(cart) || cart.hasInvoiceLine) {
            return false;
        }

        if (
            isChannelTypeB2B(this.props.context.actionContext.requestContext) &&
            this.props.data.orderTemplates.result &&
            ArrayExtensions.hasElements(cart.cart?.CartLines) &&
            this.props.data.customerInformation.result
        ) {
            return true;
        }

        return false;
    }

    /**
     * Get promotions.
     * @returns React node with the promotions.
     */
    private _getPromotions(): React.ReactNode {
        return (
            this.props.config.showAvailablePromotions &&
            cartPromotions({
                id: this.promotionPopupId,
                showPromotionPopup: this.state.showPromotionDialog,
                onSeeAllClick: this.promotionLinkClick,
                onCloseButtonClick: this.promotionCloseButtonclick,
                promotions: this.state.promotionData.promotionOptions,
                resources: {
                    promotionStringHeading: this.props.resources.promotionStringHeading,
                    promotionLinkText: this.props.resources.promotionLinkText,
                    promotionPopupHeading: this.props.resources.promotionPopupHeading,
                    promotionCloseButtonAriaLabel: this.props.resources.promotionCloseButtonAriaLabel
                }
            })
        );
    }

    /**
     * Add error message in cart line in case the quantity exceeds the current inventory.
     * @param cartLines - The cart lines.
     * @param cartLineInventoryValidationResult - The cart line inventory result.
     */
    private _updateCartLineErrorForInvalidInventory(
        cartLines: ICartlinesViewProps[] | null,
        cartLineInventoryValidationResult: ICartLineInventoryValidationResult
    ) {
        const { resources } = this.props;

        if (
            ArrayExtensions.hasElements(cartLines) &&
            !cartLineInventoryValidationResult.isValid &&
            ArrayExtensions.hasElements(cartLineInventoryValidationResult.productIdWithErrors)
        ) {
            for (const productIdWithError of cartLineInventoryValidationResult.productIdWithErrors) {
                const cartLine = cartLines?.find(element => element.data?.cartline.ProductId === productIdWithError);
                if (cartLine) {
                    cartLine.error = resources.outOfStockErrorMessage;
                    cartLine.hasError = true;
                }
            }
        }
    }

    /**
     * Get order summary errors.
     * @param cartLines - The cart lines.
     * @returns Order summary errors.
     */
    private _getOrderSummaryErrors(cartLines: ICartlinesViewProps[] | null): IOrderSummaryErrors | undefined {
        const allErrors =
            (cartLines &&
                cartLines
                    .map(cartline => {
                        // Check if the product is service or not by product type
                        const isServiceItem = cartline.data?.product?.ItemTypeValue === ReleasedProductType.Service;

                        if (!isServiceItem && cartline.error) {
                            const fullError =
                                cartline.data && cartline.data.product?.Name
                                    ? `${cartline.data.product.Name}: ${cartline.error}`
                                    : cartline.error;

                            return (
                                <div key={fullError} className='msc-alert__line'>
                                    {fullError}
                                </div>
                            );
                        }

                        return null;
                    })
                    .filter((line): line is JSX.Element => !!line)) ||
            [];

        return {
            Wrapper: {
                tag: Alert,
                className: 'msc-alert',
                isOpen: allErrors.length > 0,
                color: 'danger',
                assertive: true,
                'aria-label': this.props.resources.outOfStockErrorMessageHeader
            },
            header: (
                <div className='msc-alert__header' aria-hidden='true'>
                    <span className='msi-exclamation-triangle' />
                    <span>{this.props.resources.outOfStockErrorMessageHeader}</span>
                </div>
            ),
            errors: allErrors
        };
    }

    /**
     * Gets invoice summary line items.
     * @returns Invoice summary lines.
     */
    private _getInvoiceSummaryLineItems(): IInvoiceSummaryLines | undefined {
        const {
            data: {
                cart: { result: cart }
            },
            telemetry,
            resources
        } = this.props;

        return cart?.hasInvoiceLine
            ? InvoiceSummary({
                  orderTotalLabel: resources.totalAmountLabel,
                  invoiceLabel: resources.invoiceLabel,
                  cart: cart.cart,
                  context: this.props.context,
                  typeName: this.props.typeName,
                  telemetry,
                  id: this.props.id
              })
            : undefined;
    }

    /**
     * Gets order summary line items.
     * @returns Order summary lines.
     */
    private _getOrderSummaryLineItems(): IOrderSummaryLines | undefined {
        const {
            data: {
                cart: { result: cart },
                channelDeliveryOptionConfig
            },
            telemetry,
            resources
        } = this.props;

        const channelConfiguration = this.props.context && this.props.context.request && this.props.context.request.channel;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const featureState = this.props?.data?.featureState;
        const retailMultiplePickUpOptionEnabled = featureState?.result?.find(item => item.Name === multiplePickupStoreSwitchName)
            ?.IsEnabled;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- app configs are of generic type
        const isShowOrHideTaxEnabled = this.props.context.request.app.config?.isEnableShowOrHideSalesTaxECommerceEnabled === true;

        return channelConfiguration && ArrayExtensions.hasElements(cart?.cart.CartLines) && !cart?.hasInvoiceLine
            ? OrderSummary({
                  cart: cart!.cart,
                  subTotalLabel: resources.itemsWithCountLabel,
                  shippingLabel: resources.estimatedShippingLabel,
                  otherChargeLabel: resources.otherCharges,
                  taxLabel: resources.estimatedTaxLabel,
                  orderTotalLabel: resources.orderTotal,
                  totalDiscountsLabel: resources.totalDiscountsLabel,
                  context: this.props.context,
                  typeName: this.props.typeName,
                  id: this.props.id,
                  toBeCalculatedText: resources.yetToBeCalculatedText,
                  freeText: resources.priceFree,
                  channelConfiguration,
                  retailMultiplePickUpOptionEnabled,
                  channelDeliveryOptionConfig: channelDeliveryOptionConfig?.result,
                  telemetry,
                  isTaxIncludedInPrice: cart!.cart.IsTaxIncludedInPrice,
                  isShowTaxBreakup: isShowOrHideTaxEnabled
              })
            : undefined;
    }

    /**
     * Gets promo code.
     * @returns React node with the promo code.
     */
    private _getPromoCode(): React.ReactNode {
        const {
            data: {
                cart: { result: cart }
            },
            resources
        } = this.props;

        return (
            cart && (
                <PromoCodeComponent
                    cart={cart}
                    promoCodeHeadingText={resources.promoCodeHeadingText}
                    promoPlaceholderText={resources.promoPlaceholderText}
                    promoCodeApplyButtonText={resources.promoCodeApplyButtonText}
                    appliedPromoCodeHeadingText={resources.appliedPromoCodeHeadingText}
                    collapseTimeOut={350}
                    removePromoAriaLabelFormat={resources.removePromoAriaLabelFormat}
                    removePromoText={resources.removePromoText}
                    invalidPromoCodeErrorText={resources.invalidPromoCodeErrorText}
                    failedToAddPromoCodeErrorText={resources.failedToAddPromoCodeErrorText}
                    failedToRemovePromoCodeErrorText={resources.failedToRemovePromoCodeErrorText}
                    duplicatePromoCodeErrorText={resources.duplicatePromotionErrorText}
                    context={this.props.context}
                    id={this.props.id}
                    typeName={this.props.typeName}
                    data={{}}
                    telemetryContent={this.telemetryContent}
                />
            )
        );
    }

    /**
     * Generate add to order template dialog resources.
     * @param resources - The resources.
     * @returns IAddToOrderTemplateDialogResources.
     */
    private _generateAddToOrderTemplateDialogResources(resources: ICartResources): IAddToOrderTemplateDialogResources {
        return {
            addToOrderTemplateHeader: resources.addToOrderTemplateHeader,

            noOrderTemplatesMessage: resources.noOrderTemplatesMessage,
            noOrderTemplatesDescription: resources.noOrderTemplatesDescription,

            createAnOrderTemplateButtonText: resources.createAnOrderTemplateButtonText,
            createNewOrderTemplateButtonText: resources.createNewOrderTemplateButtonText,
            cancelOrderTemplateCreationButtonText: resources.cancelOrderTemplateCreationButtonText,

            selectTemplatesText: resources.selectTemplatesText,
            addToTemplateButtonText: resources.addToTemplateButtonText,
            lineItemsText: resources.lineItemsText
        };
    }

    /**
     * Generate item added to order template dialog resources.
     * @param resources - The resources.
     * @returns IItemAddedToOrderTemplateDialogResources.
     */
    private _generateItemAddedToOrderTemplateDialogResources(resources: ICartResources): IItemAddedToOrderTemplateDialogResources {
        return {
            viewOrderTemplateButtonText: resources.viewOrderTemplateButtonText,
            continueShoppingButtonText: resources.continueShoppingButtonText,
            itemAddedToOrderTemplateHeaderItemOneText: resources.itemAddedToOrderTemplateHeaderItemOneText,
            itemAddedToOrderTemplateHeaderItemFormatText: resources.itemAddedToOrderTemplateHeaderItemFormatText,
            itemAddedToOrderTemplateHeaderMessageText: resources.itemAddedToOrderTemplateHeaderMessageText,
            freePriceText: resources.freePriceText,
            originalPriceText: resources.originalPriceText,
            currentPriceText: resources.currentPriceText
        };
    }

    /**
     * Generate lines added to order template dialog resources.
     * @param resources - The resources.
     * @returns ILinesAddedToOrderTemplateDialogResources.
     */
    private _generateLinesAddedToOrderTemplateDialogResources(resources: ICartResources): ILinesAddedToOrderTemplateDialogResources {
        return {
            viewOrderTemplateButtonText: resources.viewOrderTemplateButtonText,
            continueShoppingButtonText: resources.continueShoppingButtonText,
            linesAddedToOrderTemplateHeaderItemsOneText: resources.linesAddedToOrderTemplateHeaderItemsOneText,
            linesAddedToOrderTemplateHeaderItemsFormatText: resources.linesAddedToOrderTemplateHeaderItemsFormatText,
            linesAddedToOrderTemplateHeaderLinesOneText: resources.linesAddedToOrderTemplateHeaderLinesOneText,
            linesAddedToOrderTemplateHeaderLinesFormatText: resources.linesAddedToOrderTemplateHeaderLinesFormatText,
            linesAddedToOrderTemplateHeaderMessageText: resources.linesAddedToOrderTemplateHeaderMessageText,
            linesAddedToOrderTemplateCustomPriceAlertMessageText: resources.linesAddedToOrderTemplateCustomPriceAlertMessageText
        };
    }

    /**
     * Generate duplicate items when adding to order template dialog resources.
     * @param resources - The resources.
     * @returns IDuplicateItemsWhenAddingToOrderTemplateDialogResources.
     */
    private _generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(
        resources: ICartResources
    ): IDuplicateItemsWhenAddingToOrderTemplateDialogResources {
        return {
            duplicatedProductsHeader: resources.duplicatedProductsHeader,
            duplicatedProductsDescription: resources.duplicatedProductsDescription,
            updateQuantityButtonText: resources.updateQuantityButtonText,
            cancelDuplicateItemsButtonText: resources.cancelDuplicateItemsButtonText
        };
    }

    /**
     * Generate order template name dialog resources.
     * @param resources - The resources.
     * @returns IOrderTemplateNameDialogResources.
     */
    private _generateOrderTemplateNameDialogResources(resources: ICartResources): IOrderTemplateNameDialogResources {
        return {
            orderTemplateHeaderLabel: resources.createOrderTemplateHeader,
            orderTemplateTitleLabel: resources.orderTemplateTitle,
            orderTemplateNameAriaLabel: resources.orderTemplateNameAriaLabel,
            orderTemplateDescription: resources.createOrderTemplateDescription,

            defaultOrderTemplateName: resources.defaultOrderTemplateName,

            orderTemplateButtonLabel: resources.createOrderTemplateButtonText,
            orderTemplateCancelButtonLabel: resources.cancelNewOrderTemplateCreationButtonText
        };
    }

    /**
     * Gets the cart lines view props.
     * @returns ICartlinesViewProps [].
     */
    private _getCartLines(): ICartlinesViewProps[] | null {
        const {
            data: {
                cart: { result: cart },
                wishlists: { result: wishlists },
                orderTemplates: { result: orderTemplates },
                customerInformation: { result: customerInformation }
            },
            context: {
                request: { channel: { PickupDeliveryModeCode } = { PickupDeliveryModeCode: undefined } }
            },
            config,
            telemetry,
            resources,
            modules
        } = this.props;

        const imageSettings = this.getImageSettings(config.imageSettings);

        const RetailMultiplePickupFeatureState = this.props.data.featureState.result?.find(
            featureState => featureState.Name === 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature'
        );
        const multiplePickUpEnabled = RetailMultiplePickupFeatureState?.IsEnabled;

        const cartlinesErrors: CartLineValidationResultsByLineId = this.state.cartlinesErrors;
        let storeSelectorId: string = '';
        if (modules && Object.keys(modules).length > 0 && modules.storeSelector && modules.storeSelector.length > 0) {
            storeSelectorId = modules.storeSelector[0].id;
        }
        const channelMultipleCatalogsFeature = 'Dynamics.AX.Application.ChannelMultipleCatalogsFeature';
        const isMultipleCatalogsFeatureEnabled =
            this.props.data.featureState.result?.find((item: FeatureState) => item.Name === channelMultipleCatalogsFeature)?.IsEnabled ||
            false;
        return ArrayExtensions.hasElements(cart?.cart.CartLines)
            ? CartLineItems({
                  cartlines: cart!.cart.CartLines,
                  storeSelectorModuleId: storeSelectorId,
                  cartlinesErrors,
                  products: this.props.data.products.result,
                  productAvailabilites: this.props.data.productAvailabilites.result,
                  productDeliveryOptions: this.props.data.deliveryOptions.result,
                  catalogs: this.props.data.catalogs?.result,
                  imageSettings,
                  isStockCheckEnabled: this.props.context.app.config.enableStockCheck || false,
                  maxCartlineQuantity: updateMaxQuantityForCartLineItem(this.props.context.app.config.maxQuantityForCartLineItem),
                  shouldIgnoreWarehouse: this.props.context.app.config.warehouseAggregation === 'multiple',
                  gridSettings: this.props.context.request.gridSettings!,
                  context: this.props.context,
                  typeName: this.props.typeName,
                  id: this.props.id,
                  retailMulitplePickupFeatureState: multiplePickUpEnabled,
                  resources: {
                      sizeString: resources.productDimensionTypeSize,
                      colorString: resources.productDimensionTypeColor,
                      configString: resources.productDimensionTypeConfiguration,
                      styleString: resources.productDimensionTypeStyle,
                      amountString: resources.productDimensionTypeAmount,
                      quantityDisplayString: resources.quantityDisplayText,
                      inputQuantityAriaLabel: resources.inputQuantityAriaLabel,
                      decrementButtonAriaLabel: resources.decrementButtonAriaLabel,
                      incrementButtonAriaLabel: resources.incrementButtonAriaLabel,
                      discountStringText: resources.discountStringText,
                      originalPriceText: resources.originalPriceText,
                      currentPriceText: resources.currentPriceText,
                      shippingChargesText: resources.shippingCharges,
                      salesAgreementPricePrompt: resources.salesAgreementPricePrompt,
                      priceEditorResources: {
                          ...resources
                      }
                  },
                  telemetry,
                  addToWishlistButtonText: resources.addToWishlistButtonText,
                  removeFromWishlistButtonText: resources.removeFromWishlistButtonText,
                  removeButtonText: resources.removeCartButtonText,
                  shipItText: resources.shipInsteadDisplayText,
                  pickitUpText: resources.pickItUpDisplayText,
                  changeStoreText: resources.changeStoreDisplayText,
                  storeSelectorStateManager: this.props.data.storeSelectorStateManager.result,
                  outOfStockText: resources.outOfStockErrorMessage,
                  outOfRangeOneText: resources.errorMessageOutOfRangeOneLeft,
                  outOfRangeFormatText: resources.errorMessageOutOfRangeFormat,
                  cartState: this.props.data.cart.result,
                  orgUnitLocations: this.props.data.orgUnitLocations.result,
                  removeItemClickHandler: this.removeItemFromCartHandler,
                  moveToWishlistSuccessHandler: this.moveToWishlistSuccessHandler,
                  updateCartLinesQuantitySuccessHandler: this.updateCartlineQuantity,
                  locationChangedHandler: this.fulfillmentStoreIdUpdated,
                  wishlists,
                  defaultWishlistName: resources.defaultWishlistName,
                  pickupDeliveryModeCode: PickupDeliveryModeCode,
                  includeErrors: config.showOutOfStockErrors,
                  showShippingChargesForLineItems: config.showShippingChargesForLineItems,
                  telemetryContent: this.telemetryContent,
                  isQuantityLimitsFeatureEnabled: this.isQuantityLimitsFeatureEnabled,

                  addToOrderTemplateDialogResources: this._generateAddToOrderTemplateDialogResources(resources),
                  createOrderTemplateDialogResources: this._generateOrderTemplateNameDialogResources(resources),
                  itemAddedToOrderTemplateDialogResources: this._generateItemAddedToOrderTemplateDialogResources(resources),
                  duplicateItemsWhenAddingToOrderTemplateDialogResources: this._generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(
                      resources
                  ),

                  addToOrderTemplateButtonText: resources.addToOrderTemplateButtonText,
                  addToOrderTemplateButtonTooltip: resources.addToOrderTemplateButtonTooltip,
                  addToOrderTemplateMessage: resources.addToOrderTemplateMessage,
                  addItemToOrderTemplateError: resources.addItemToOrderTemplateError,
                  orderTemplates,
                  customerInformation,
                  productAvailability: this.props.data.productAvailabilites,
                  isMultipleCatalogFeatureEnabledInHq: isMultipleCatalogsFeatureEnabled || false
              })
            : null;
    }

    /**
     * Gets the checkout URL.
     * @param isAuthenticated - Is authenticated flag.
     * @param guestCheckoutUrl - Guest checkout URL.
     * @param signInUrl -The sign in URL.
     * @returns The checkout URL.
     */
    private getCheckoutURL(isAuthenticated: boolean, guestCheckoutUrl: string, signInUrl: string): string {
        if (isAuthenticated) {
            return guestCheckoutUrl;
        }

        const isAbsoluteUrl = urlCheck(guestCheckoutUrl);
        let returnURL = guestCheckoutUrl;
        if (MsDyn365.isBrowser && !isAbsoluteUrl) {
            returnURL = `${window.location.origin}${guestCheckoutUrl}`;
        }

        return `${signInUrl}${!signInUrl.includes('?') ? '?' : '&'}ru=${returnURL}`;
    }

    /**
     * Gets the image settings.
     * @param imageSettings - Image settings.
     * @returns IImageSettings.
     */
    private readonly getImageSettings = (imageSettings: IImageSettings | undefined): IImageSettings => {
        return (
            imageSettings || {
                viewports: {
                    xs: { q: 'w=80&h=94&m=6', w: 0, h: 0 },
                    sm: { q: 'w=148&h=174&m=6', w: 0, h: 0 },
                    lg: { q: 'w=148&h=174&m=6', w: 0, h: 0 }
                },
                lazyload: true
            }
        );
    };

    /**
     * Remove item from cart handler.
     * @param cartlineToRemove - The cart line to remove.
     */
    private readonly removeItemFromCartHandler = (cartlineToRemove: CartLine) => {
        if (this.props.data.cart.result) {
            const input = {
                cartLineIds: [cartlineToRemove.LineId!.toString()]
            };
            this.props.data.cart.result
                .removeCartLines(input)
                .then(() => {
                    this.validateCart().catch(error => {
                        this.props.telemetry.warning(error);
                        this.props.telemetry.debug('Unable to validate Cart');
                    });
                })
                .catch(error => {
                    this.props.telemetry.warning(error);
                    this.props.telemetry.debug('Unable to Remove Cart Line');
                });
        }
    };

    /**
     * Move to wish list handler.
     * @param result - The wish list action success result.
     * @param cartline - The cart line.
     */
    private readonly moveToWishlistSuccessHandler = (result: IWishlistActionSuccessResult, cartline?: CartLine) => {
        if (result.status === 'ADDED' && cartline) {
            this.removeItemFromCartHandler(cartline);
        }
    };

    /**
     * Updates the cart line quantity.
     * @param cartlineToUpdate - The cart line.
     * @param quantity - The quantity.
     * @param lineIndex - The line index.
     * @returns True if the cart line was updated, false otherwise.
     */
    private readonly updateCartlineQuantity = (cartlineToUpdate: CartLine, quantity: number, lineIndex?: number): boolean => {
        cartLineQuantityUpdatedAsync(
            this.isQuantityLimitsFeatureEnabled,
            this.props.data.cart.result,
            this.props.telemetry,
            this.props.data.products.result,
            cartlineToUpdate,
            quantity
        )
            .then((cartActionResult: ICartActionResult | undefined): boolean => {
                if (cartActionResult?.status === 'SUCCESS') {
                    this.validateCart().catch(error => {
                        this.props.telemetry.warning((error as Error).message);
                        this.props.telemetry.debug('Unable to validate Cart');
                    });
                    this.setState({
                        cartlinesErrors: {}
                    });
                    return true;
                }

                if (!ObjectExtensions.isNullOrUndefined(cartActionResult)) {
                    // Show update line error message.
                    const lineUpdateFailure: LineValidationResult = {
                        LineId: ObjectExtensions.isNullOrUndefined(cartlineToUpdate.LineId) ? '0' : cartlineToUpdate.LineId,
                        ValidationFailures: [
                            {
                                ErrorContext: ArrayExtensions.hasElements(cartActionResult.validationResults)
                                    ? cartActionResult.validationResults[0].ErrorContext
                                    : '',
                                LocalizedMessage: cartActionResult.errorDetails?.LocalizedMessage
                            }
                        ]
                    };

                    this.setState({
                        cartlinesErrors: { ValidationResultsPairs: [lineUpdateFailure] }
                    });
                }

                return false;
            })
            .catch(() => {
                return false;
            });

        return false;
    };

    /**
     * Fulfillment store id is updated.
     */
    private readonly fulfillmentStoreIdUpdated = () => {
        if (this.isQuantityLimitsFeatureEnabled) {
            // Refresh products (in props.data) based on latest cart.
            getActiveCartProductsAction(new ActiveCartProductsInput(), this.props.context.actionContext)
                .then(async () => this.validateCart())
                .catch((error: Error) => {
                    this.props.telemetry.warning(error.message);
                    this.props.telemetry.debug('Unable to validate Cart');
                });
        }
    };

    /**
     * Validates cart.
     * @returns Void promise.
     */
    private async validateCart(): Promise<void> {
        if (!this.isQuantityLimitsFeatureEnabled) {
            this.setState({ cartlinesErrors: {}, isCartValid: true });
            return AsyncResult.resolve();
        }

        const {
            data: { cart },
            telemetry,
            context
        } = this.props;

        const validationResults: CartLineValidationResultsByLineId | undefined = await validateCartAsync(cart, telemetry, context, true);

        if (validationResults) {
            const isValid = !ArrayExtensions.hasElements(validationResults.ValidationResultsPairs);
            this.setState({
                cartlinesErrors: validationResults,
                isCartValid: isValid
            });
        } else {
            this.setState({ cartlinesErrors: {}, isCartValid: true });
        }

        return AsyncResult.resolve();
    }

    /**
     * Get order quantity limit feature flag.
     * @returns True if flag is enabled, false otherwise.
     */
    private async getOrderQuantityLimitsFeatureFlag(): Promise<boolean> {
        const featureStatuses = await this.props.data.featureState;

        try {
            const isQuantityLimitsFeatureEnabledInHq =
                featureStatuses.find(
                    featureState => featureState.Name === 'Dynamics.AX.Application.RetailDefaultOrderQuantityLimitsFeature'
                )?.IsEnabled || false;
            if (!isQuantityLimitsFeatureEnabledInHq) {
                return false;
            }
        } catch (error) {
            this.props.telemetry.warning(error);
            this.props.telemetry.debug('Unable to get feature states');
            return false;
        }

        const useSiteBuilderSettings = featureStatuses?.find(
            featureState => featureState.Name === 'RevertToSiteBuilderOrderQuantityLimitsSettings'
        )?.IsEnabled;

        if (useSiteBuilderSettings) {
            const defaultOrderQuantityLimitsFeatureConfig = this.props.context?.request?.app?.platform?.enableDefaultOrderQuantityLimits;
            if (defaultOrderQuantityLimitsFeatureConfig === 'none') {
                return false;
            }

            if (defaultOrderQuantityLimitsFeatureConfig === 'all') {
                return true;
            }

            try {
                const customerInfo = await this.props.data.customerInformation;
                return (
                    !!customerInfo &&
                    ((defaultOrderQuantityLimitsFeatureConfig === 'b2b' && customerInfo.IsB2b) ||
                        (defaultOrderQuantityLimitsFeatureConfig === 'b2c' && !customerInfo.IsB2b))
                );
            } catch (error) {
                this.props.telemetry.warning(error);
                this.props.telemetry.debug('Unable to get customer info');
                return false;
            }
        } else {
            const cartConfiguration = await this.props.data.cartConfiguration;
            return !(cartConfiguration?.IgnoreOrderSettings ?? false);
        }
    }

    private async _isChannelLimitsFeatureEnabled(): Promise<boolean> {
        const featureStatuses = await this.props.data.featureState;

        const isChannelLimitsFeatureEnabledInHq = featureStatuses?.find(
            featureState => featureState.Name === 'Dynamics.AX.Application.EcommerceQuantityLimitConfigurationsFeature'
        )?.IsEnabled;

        return isChannelLimitsFeatureEnabledInHq ?? false;
    }

    /**
     * Gets the cart lines group.
     * @returns ICartlinesViewProps [][].
     */
    private getCartLinesGroup(): ICartlinesViewProps[][] | null {
        const {
            data: {
                cart: { result: cart },
                wishlists: { result: wishlists },
                orderTemplates: { result: orderTemplates },
                customerInformation: { result: customerInformation }
            },
            context: {
                request: { channel: { PickupDeliveryModeCode } = { PickupDeliveryModeCode: undefined } }
            },
            config,
            telemetry,
            resources,
            modules
        } = this.props;

        const imageSettings = this.getImageSettings(config.imageSettings);
        const cartlinesErrors: CartLineValidationResultsByLineId = this.state.cartlinesErrors;
        let storeSelectorId: string = '';
        if (modules && Object.keys(modules).length > 0 && modules.storeSelector && modules.storeSelector.length > 0) {
            storeSelectorId = modules.storeSelector[0].id;
        }

        const RetailMultiplePickupFeatureState = this.props.data.featureState.result?.find(
            featureState => featureState.Name === 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature'
        );
        const multiplePickUpEnabled = RetailMultiplePickupFeatureState?.IsEnabled;
        const { featureState } = this.props.data;
        const channelMultipleCatalogsFeature = 'Dynamics.AX.Application.ChannelMultipleCatalogsFeature';
        const isMultipleCatalogsFeatureEnabled =
            featureState.result?.find((item: FeatureState) => item.Name === channelMultipleCatalogsFeature)?.IsEnabled || false;
        return this.props.data.products &&
            (cart?.hasInvoiceLine || this.props.data.products.result) &&
            cart &&
            cart.cart.CartLines &&
            cart.cart.CartLines.length > 0 &&
            this.props.data.channelDeliveryOptionConfig?.result
            ? CartLineGroupItems({
                  cartlines: cart.cart.CartLines,
                  storeSelectorModuleId: storeSelectorId,
                  cartlinesErrors,
                  products: this.props.data.products.result,
                  productAvailabilites: this.props.data.productAvailabilites.result,
                  productDeliveryOptions: this.props.data.deliveryOptions.result,
                  catalogs: this.props.data.catalogs?.result,
                  imageSettings,
                  isStockCheckEnabled: this.props.context.app.config.enableStockCheck || false,
                  hasInvoiceLine: cart?.hasInvoiceLine || false,
                  maxCartlineQuantity: updateMaxQuantityForCartLineItem(this.props.context.app.config.maxQuantityForCartLineItem),
                  gridSettings: this.props.context.request.gridSettings!,
                  context: this.props.context,
                  retailMulitplePickupFeatureState: multiplePickUpEnabled,
                  typeName: this.props.typeName,
                  id: this.props.id,
                  resources: {
                      sizeString: resources.productDimensionTypeSize,
                      colorString: resources.productDimensionTypeColor,
                      configString: resources.productDimensionTypeConfiguration,
                      styleString: resources.productDimensionTypeStyle,
                      amountString: resources.productDimensionTypeAmount,
                      quantityDisplayString: resources.quantityDisplayText,
                      inputQuantityAriaLabel: resources.inputQuantityAriaLabel,
                      decrementButtonAriaLabel: resources.decrementButtonAriaLabel,
                      incrementButtonAriaLabel: resources.incrementButtonAriaLabel,
                      discountStringText: resources.discountStringText,
                      originalPriceText: resources.originalPriceText,
                      currentPriceText: resources.currentPriceText,
                      shippingChargesText: resources.shippingCharges,
                      salesAgreementPricePrompt: resources.salesAgreementPricePrompt,
                      priceEditorResources: {
                          ...resources
                      }
                  },
                  telemetry,
                  addToWishlistButtonText: resources.addToWishlistButtonText,
                  removeFromWishlistButtonText: resources.removeFromWishlistButtonText,
                  removeButtonText: resources.removeCartButtonText,
                  shipItText: resources.shipInsteadDisplayText,
                  pickitUpText: resources.pickItUpDisplayText,
                  changeStoreText: resources.changeStoreDisplayText,
                  storeSelectorStateManager: this.props.data.storeSelectorStateManager.result,
                  outOfStockText: resources.outOfStockErrorMessage,
                  outOfRangeOneText: resources.errorMessageOutOfRangeOneLeft,
                  outOfRangeFormatText: resources.errorMessageOutOfRangeFormat,
                  cartState: this.props.data.cart.result,
                  orgUnitLocations: this.props.data.orgUnitLocations.result,
                  removeItemClickHandler: this.removeItemFromCartHandler,
                  moveToWishlistSuccessHandler: this.moveToWishlistSuccessHandler,
                  updateCartLinesQuantitySuccessHandler: this.updateCartlineQuantity,
                  locationChangedHandler: this.fulfillmentStoreIdUpdated,
                  wishlists,
                  defaultWishlistName: resources.defaultWishlistName,
                  pickupDeliveryModeCode: PickupDeliveryModeCode,
                  includeErrors: config.showOutOfStockErrors,
                  showShippingChargesForLineItems: config.showShippingChargesForLineItems,
                  telemetryContent: this.telemetryContent,
                  isQuantityLimitsFeatureEnabled: this.isQuantityLimitsFeatureEnabled,

                  addToOrderTemplateDialogResources: this._generateAddToOrderTemplateDialogResources(resources),
                  createOrderTemplateDialogResources: this._generateOrderTemplateNameDialogResources(resources),
                  itemAddedToOrderTemplateDialogResources: this._generateItemAddedToOrderTemplateDialogResources(resources),
                  duplicateItemsWhenAddingToOrderTemplateDialogResources: this._generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(
                      resources
                  ),

                  addToOrderTemplateButtonText: resources.addToOrderTemplateButtonText,
                  addToOrderTemplateButtonTooltip: resources.addToOrderTemplateButtonTooltip,
                  addToOrderTemplateMessage: resources.addToOrderTemplateMessage,
                  addItemToOrderTemplateError: resources.addItemToOrderTemplateError,
                  orderTemplates,
                  customerInformation,
                  channelDeliveryOptionConfig: this.props.data.channelDeliveryOptionConfig?.result,
                  shouldIgnoreWarehouse: this.props.context.app.config.warehouseAggregation === 'multiple',
                  productAvailability: this.props.data.productAvailabilites,
                  productPickUpOptions: this.state.productPickUpOptions || this.props.data.cartLinesPickUpOptions?.result,
                  isMultipleCatalogFeatureEnabledInHq: isMultipleCatalogsFeatureEnabled || false
              })
            : null;
    }
}

export default Cart;

/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import * as Msdyn365 from '@msdyn365-commerce/core';
import { isChannelTypeB2B } from '@msdyn365-commerce/core';
import { AsyncResultStatus, Cart, CartLineValidationResults } from '@msdyn365-commerce/retail-proxy';
import {
    updateLineDeliverySpecificationsAsync,
    validateForCheckoutAsync
} from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import {
    Address,
    DeliveryPreferenceType,
    LineDeliverySpecification,
    SimpleProduct,
    TokenizedPaymentCard
} from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { IModuleStateManager, IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import {
    ArrayExtensions,
    getAvailabilitiesForCartLineItems,
    IProductInventoryInformation,
    ProductAvailabilitiesForCartLineItems,
    validateCartLinesInventory
} from '@msdyn365-commerce-modules/retail-actions';
import {
    Button,
    getPayloadObject,
    getTelemetryAttributes,
    getTelemetryObject,
    IModuleProps,
    INodeProps,
    ITelemetryContent,
    TelemetryConstant,
    Waiting
} from '@msdyn365-commerce-modules/utilities';
import { ErrorCode, ErrorLocation } from '@msdyn365-commerce/global-state';
import classnames from 'classnames';
import isEmpty from 'lodash/isEmpty';
import { action, computed, get, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { ICheckoutData } from './checkout.data';
import { ICheckoutHeadingData, ICheckoutProps } from './checkout.props.autogenerated';
import AlertComponent from './components/alert';
import { getInvoicePaymentSummary, IInvoicePaymentSummary } from './components/get-invoice-payment-summary';
import { getLineItems, ILineItems } from './components/get-line-items';
import { getOrderSummary, IOrderSummary } from './components/get-order-summary';
import GuidedFormComponent from './components/guided-form';
import PlaceOrderButtonComponent from './components/place-order-button';
import placeOrder from './methods/place-order';
import { focusOnCheckoutError, setCheckoutErrors } from '@msdyn365-commerce-modules/checkout';
import { AsyncResultStatusCode, IExpressPaymentDetails } from '@msdyn365-commerce-modules/checkout';

export * from './components/get-line-items';
export * from './components/get-order-summary';

/**
 * Device type.
 */
type DeviceType = 'Mobile';

/**
 * The Checkout state.
 */
interface ICheckoutState {
    errorMessage: string;
    isValidationPassed: boolean;
    isPlaceOrderLoading?: boolean;
    isPlaceOrderClicked?: boolean;
}

/**
 * Known action error failure states
 */
export const enum ActionErrorStatus {
    Timeout = 'Timeout',
    HookTimeout = 'Hook Timeout',
    ServiceUnavailable = 'Service Unavailable'
}

/**
 * The Checkout view props.
 * @extends ICheckoutProps<ICheckoutData>
 */
export interface ICheckoutViewProps extends ICheckoutProps<ICheckoutData> {
    className: string;
    canShow?: boolean;
    isEmptyCart?: boolean;
    isConsentGiven?: boolean;
    hasError?: boolean;
    isPaymentVerificationRedirection?: boolean;
    shouldEnableSinglePaymentAuthorizationCheckout?: boolean;
    cartStatus?: string;
    isMobile?: boolean;
    isEditorialMode?: boolean;
    backToShoppingUrl?: string;
    editCartLink?: string;
    hasSalesOrder: boolean;
    hasInvoiceLine?: boolean;

    moduleState?: IModuleStateManager;
    telemetryContent?: ITelemetryContent;
    checkoutGuidedFormHasError?: boolean;

    checkoutProps: IModuleProps;
    headerProps: INodeProps;
    bodyProps: INodeProps;
    mainProps: INodeProps;
    mainControlProps: INodeProps;
    sideProps: INodeProps;
    sideControlFirstProps: INodeProps;
    sideControlSecondProps: INodeProps;
    termsAndConditionsProps: INodeProps;

    guidedForm?: React.ReactNode;
    title?: React.ReactNode;
    loading?: React.ReactNode;
    alert?: React.ReactNode;
    orderSummary?: IOrderSummary;
    invoicePaymentSummary?: IInvoicePaymentSummary;
    lineItems?: ILineItems;
    placeOrderButton?: React.ReactNode;
    termsAndConditions?: React.ReactNode;
    keepShoppingButton?: React.ReactNode;
    orderConfirmation?: React.ReactNode;

    checkoutExpressPaymentContainer?: React.ReactNode;
    checkoutErrorRef?: React.RefObject<HTMLElement>;
}

/**
 * The checkout module props interface.
 */
export interface ICheckoutModuleProps extends ICheckoutProps<ICheckoutData>, IModuleStateProps {}

const expressPaymentSectionClassName = 'msc-express-payment-container';

/**
 *
 * CheckoutContainer component.
 * @extends {React.Component<ICheckoutModuleProps>}
 */
// @ts-expect-error
@withModuleState
@observer
class Checkout extends React.PureComponent<ICheckoutModuleProps> {
    @computed get cartStatus(): Msdyn365.AsyncResultStatus {
        return this.props.data.checkout?.status;
    }

    @computed get isEmptyCart(): boolean {
        if (this.isEditorialMode) {
            // Editorial mode: Ignore empty cart
            return false;
        }
        const cart = this.props.data.checkout?.result?.checkoutCart?.cart;
        return this.cartStatus === 'SUCCESS' && !!cart && !isEmpty(cart) && (!cart.CartLines || cart.CartLines.length === 0);
    }

    @computed get hasError(): boolean {
        const cart = this.props.data.checkout?.result?.checkoutCart?.cart;
        return this.cartStatus === 'FAILED' || (this.cartStatus === 'SUCCESS' && (!cart || isEmpty(cart)));
    }

    @computed get isEditorialMode(): boolean {
        return this.props.context.request.params.isEditor;
    }

    @computed get canPlaceOrder(): boolean {
        const isTermsAndConditionAccepted = this.props.data.checkout.result && this.props.data.checkout.result?.isTermsAndConditionAccepted;

        const shouldEnableSinglePaymentAuthorizationCheckout =
            this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout ?? false;

        const disableForOBO = Msdyn365.isOboRequest(this.props.context.request) && !this.isPaidOffByCustomerAccount;

        // If isTermsAndConditionAccepted is undefined means TermsAndCondition module is not added to page and we should able to place order.
        return (
            this.props.moduleState.isReady &&
            (isTermsAndConditionAccepted === undefined || isTermsAndConditionAccepted || shouldEnableSinglePaymentAuthorizationCheckout) &&
            (this.state.errorMessage === '' ||
                shouldEnableSinglePaymentAuthorizationCheckout ||
                (this.props.data.checkout.result?.isPaymentVerificationRedirection ?? false)) &&
            !(shouldEnableSinglePaymentAuthorizationCheckout && disableForOBO)
        );
    }

    @computed get isPaidOffByCustomerAccount(): boolean {
        const amountDue = this.props.data.checkout.result?.checkoutCart.cart.TotalAmount ?? 0;
        const customerAccountAmount = this.props.data.checkout.result?.customerAccountAmount ?? 0;

        return customerAccountAmount === amountDue;
    }

    @computed get isCartReady(): boolean {
        return (
            !!this.props.data.checkout.result?.checkoutCart?.cart &&
            this.props.data.customerInformation.status !== 'LOADING' &&
            this.props.data.featureState.status !== 'LOADING'
        );
    }

    public get expressPaymentDetailsFromCartPage(): IExpressPaymentDetails | null {
        const properties =
            this.props.data.checkout?.result?.checkoutCart?.cart?.ExtensionProperties?.find(
                property => property.Key === 'expressPaymentDetails'
            )?.Value?.StringValue ?? '';
        return properties ? (JSON.parse(properties) as IExpressPaymentDetails) : null;
    }

    public state: ICheckoutState = {
        errorMessage: '',
        isValidationPassed: false,
        isPlaceOrderLoading: false,
        isPlaceOrderClicked: false
    };

    private readonly telemetryContent: ITelemetryContent = getTelemetryObject(
        this.props.context.request.telemetryPageName!,
        this.props.friendlyName,
        this.props.telemetry
    );

    private readonly checkoutErrorRef: React.RefObject<HTMLElement> = React.createRef();

    public componentDidMount(): void {
        const {
            resources: { genericErrorMessage }
        } = this.props;

        when(
            () => this.asyncResultStatus !== AsyncResultStatusCode.LOADING,
            async () => {
                if (this.expressPaymentDetailsFromCartPage) {
                    const {
                        email,
                        tenderLine,
                        tokenizedPaymentCard,
                        paymentTenderType: paymentTenderTypeFromCartPage,
                        isExpressCheckoutAppliedInCartPage,
                        isExpressAddressAppliedInCartPage,
                        cardPaymentAcceptResult,
                        address
                    } = this.expressPaymentDetailsFromCartPage;

                    this.props.data.checkout.result?.updateExpressCheckoutDetails({
                        newEmailAddressFromExpressCheckout: email ?? '',
                        newTenderLine: tenderLine,
                        newTokenizedPaymentCard: tokenizedPaymentCard,
                        newPaymentTenderType: paymentTenderTypeFromCartPage,
                        newIsExpressCheckoutApplied: isExpressCheckoutAppliedInCartPage,
                        newIsExpressAddressApplied: isExpressAddressAppliedInCartPage,
                        newCardPaymentAcceptResult: cardPaymentAcceptResult
                    });

                    if (isExpressAddressAppliedInCartPage && address) {
                        this.props.data.checkout.result?.updateBillingAddressFromExpressCheckout({
                            newBillingAddressFromExpressCheckout: address
                        });
                        this.props.data.checkout.result?.updateShippingAddressFromExpressCheckout({
                            newShippingAddressFromExpressCheckout: address
                        });
                    } else {
                        void this._saveShippingAndBillingAddress(tokenizedPaymentCard);
                    }

                    this.props.data.checkout.result?.checkoutCart.updateExtensionProperties({
                        newExtensionProperties: [
                            {
                                Key: 'expressPaymentDetails',
                                Value: { StringValue: '' }
                            }
                        ]
                    });
                }
            }
        );

        when(
            () => this.hasError,
            () => {
                this.setState({
                    errorMessage: genericErrorMessage
                });
                this.props.context.telemetry.error('Failed to get cart');
            }
        );

        when(
            () => {
                return this.isEmptyCart;
            },
            () => {
                this.redirectToCartPage('Cart is empty, but no editCartLink found');
            }
        );

        when(
            () => this.isCartReady,
            () => {
                this.validateForCheckout();
            }
        );

        reaction(
            () => this.props.moduleState.isReady,
            () => {
                this.onContainerReady();
            }
        );

        // Reaction to call place order when isPaymentSectionContainerReady is true for new checkout flow.
        reaction(
            () => this.props.data.checkout.result?.isPaymentSectionContainerReady,
            async isReady => {
                if (
                    this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout &&
                    isReady &&
                    !this.props.data.checkout.result?.redirectAdditionalContext &&
                    (!this.props.data.checkout.result?.isExpressCheckoutApplied ||
                        this.props.data.checkout.result?.isPaymentVerificationRedirection)
                ) {
                    if (!this.state.isPlaceOrderLoading) {
                        this.setState({ isPlaceOrderLoading: true });
                    }

                    this.props.telemetry.information(
                        'Call onPlaceOrder as reaction when isPaymentSectionContainerReady is updated for single auth payment.'
                    );

                    await this.onPlaceOrder();

                    // If 3D authentication redirection, don't update isPlaceOrderLoading
                    if (!this.props.data.checkout.result.isPaymentVerificationRequired) {
                        this.setState({ isPlaceOrderLoading: false });
                    }
                }
            }
        );

        // Reaction to enable place order button when isPaymentSectionContainerHasError is true for new checkout flow.
        reaction(
            () => this.props.data.checkout.result?.isPaymentSectionContainerHasError,
            hasError => {
                if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && hasError) {
                    this.setState({ isPlaceOrderLoading: false });

                    this.props.telemetry.information(
                        'Enable place order button as reaction when isPaymentSectionContainerHasError is updated to true for single auth payment.'
                    );
                } else {
                    this.props.telemetry.information(
                        'No reaction when isPaymentSectionContainerHasError is updated to false or not single auth payment.'
                    );
                }
            }
        );

        reaction(
            () => this.props.data.checkout.result?.isBillingAddressHasError,
            hasError => {
                if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && hasError) {
                    this.setState({ isPlaceOrderLoading: false });

                    this.props.data.checkout.result?.updateIsBillingAddressHasError({ newIsBillingAddressHasError: false });

                    this.props.telemetry.information(
                        'Enable place order button as reaction when isBillingAddressHasError is updated to true for single auth payment.'
                    );
                } else {
                    this.props.telemetry.information(
                        'No reaction when isBillingAddressHasError is updated to false or not single auth payment.'
                    );
                }
            }
        );

        // Reaction to enable place order button when redirection is true for new checkout flow.
        reaction(
            () => this.canPlaceOrder,
            async () => {
                if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && this.canPlaceOrder) {
                    if (this.props.data.checkout.result?.isPaymentVerificationRedirection) {
                        await this.props.data.checkout.result.updateIsPlaceOrderEnabledInRedirection({
                            newIsPlaceOrderEnabledInRedirection: true
                        });

                        this.props.telemetry.information(
                            'Set isPaymentVerificationRedirection to true as reaction when canPlaceOrder is updated to true for single auth payment.'
                        );
                    } else {
                        this.props.telemetry.information(
                            'No reaction when canPlaceOrder is updated to true but isPaymentVerificationRedirection is false for single auth payment.'
                        );
                        this.props.telemetry.information(
                            `isOBORequest is ${Msdyn365.isOboRequest(this.props.context.request)} and canPlaceOrder is ${
                                this.canPlaceOrder
                            }.`
                        );
                    }
                } else {
                    this.props.telemetry.information('No reaction when canPlaceOrder is updated to false or not single auth payment.');
                }
            }
        );

        // Reaction to update the error message when there is a checkout error.
        reaction(
            () => this.props.data.checkout.result?.checkoutError,
            checkoutError => {
                const checkoutErrorLocation: boolean = checkoutError?.errorLocation === ErrorLocation.Checkout;
                // If there is an Error in CheckoutPaymentInstrument module, checkout error location will be updated.
                const checkoutPaymentErrorLocation: boolean =
                    checkoutError?.errorCode === ErrorCode.Microsoft_Dynamics_Commerce_Runtime_UnableToAuthorizePayment
                        ? checkoutError.errorLocation === ErrorLocation.CheckoutPaymentInstrument
                        : checkoutErrorLocation;
                if (
                    this.props.data.checkout.result?.shouldEnableCheckoutErrorDisplayMessaging &&
                    checkoutError &&
                    checkoutError.errorMessage &&
                    (checkoutErrorLocation ? checkoutErrorLocation : checkoutPaymentErrorLocation)
                ) {
                    this._setErrorMessage(checkoutError.errorMessage);
                }
            }
        );
    }

    public componentDidUpdate(): void {
        if (
            this.props.data.checkout.result?.shouldEnableCheckoutErrorDisplayMessaging &&
            this.props.data.checkout.result?.shouldFocusOnCheckoutError &&
            this.state.errorMessage
        ) {
            focusOnCheckoutError(this.checkoutErrorRef, this.props.context.actionContext);
        }
    }

    // eslint-disable-next-line complexity -- ignore the complexity.
    public render(): JSX.Element {
        const {
            moduleState,
            config: { className, checkoutHeading, disableGuidedCheckoutFlow },
            resources,
            context: {
                request: {
                    user: { isAuthenticated }
                }
            }
        } = this.props;
        const { errorMessage } = this.state;
        const { backToShopping, placeOrderText, confirmPaymentText, cookieConsentRequiredMessage, genericErrorMessage } = resources;
        const checkoutClass = classnames('ms-checkout', className);
        const allCheckoutInformation = this.getSlotItems('checkoutInformation');

        // @ts-expect-error - check the key of slot
        const checkoutInformation = allCheckoutInformation?.filter(info => !info?.key.includes('express-payment'));

        // @ts-expect-error - check the key of slot
        const checkoutExpressPaymentContainer = allCheckoutInformation?.find(info => info?.key.includes('express-payment'));

        const isConsentGiven =
            this.props.context.request &&
            this.props.context.request.cookies &&
            this.props.context.request.cookies.isConsentGiven &&
            this.props.context.request.cookies.isConsentGiven();

        const isMobile =
            this.props.context.request &&
            this.props.context.request.device &&
            (this.props.context.request.device.Type as DeviceType) === 'Mobile';

        const backToShoppingUrl = Msdyn365.getUrlSync('home', this.props.context.actionContext) || '';
        const editCartLink = Msdyn365.getUrlSync('cart', this.props.context.actionContext) || '';

        const termsAndConditions =
            this.props.slots.termsAndConditions && this.props.slots.termsAndConditions.length > 0 && this.props.slots.termsAndConditions[0];

        const payLoad = getPayloadObject('click', this.telemetryContent, TelemetryConstant.BackToShopping);
        const backToShoppingAttributes = getTelemetryAttributes(this.telemetryContent, payLoad);

        const hasInvoiceLine = this.props.data.checkout && this.props.data.checkout.result?.checkoutCart.hasInvoiceLine;
        const checkoutBtnText = hasInvoiceLine ? confirmPaymentText : placeOrderText;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check for null/undefined.
        const shouldEnableSinglePaymentAuthorizationCheckout =
            this.props.data.checkout?.result?.shouldEnableSinglePaymentAuthorizationCheckout ?? false;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check null/undefined.
        const isExpressCheckoutApplied = this.props.data.checkout?.result?.isExpressCheckoutApplied ?? false;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check null/undefined.
        const hasShippingAddress = this.props.data.checkout?.result?.hasShippingAddress;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check null/undefined.
        const hasCartDeliveryMode = this.props.data.checkout?.result?.hasCartDeliveryMode;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check null/undefined.
        const hasGuestCheckoutEmail = this.props.data.checkout?.result?.hasGuestCheckoutEmail;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check null/undefined.
        const isTermsAndConditionAccepted = this.props.data.checkout?.result?.isTermsAndConditionAccepted;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check null/undefined.
        const isPaymentVerificationRedirection = this.props.data.checkout?.result?.isPaymentVerificationRedirection ?? false;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check null/undefined.
        const shouldEnableCheckoutErrorDisplayMessaging =
            this.props.data.checkout?.result?.shouldEnableCheckoutErrorDisplayMessaging ?? false;

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Explicitly check null/undefined.
        const shouldFocusOnCheckoutError = this.props.data.checkout?.result?.shouldFocusOnCheckoutError;

        let hasExpressPaymentContainer = false;

        if (
            typeof window !== 'undefined' &&
            (document?.getElementsByClassName(expressPaymentSectionClassName) as HTMLCollectionOf<HTMLElement>)[0]?.style.display === ''
        ) {
            hasExpressPaymentContainer = true;
        }

        let viewProps: ICheckoutViewProps = {
            ...this.props,
            className: checkoutClass,
            checkoutErrorRef: this.checkoutErrorRef,
            isEmptyCart: this.isEmptyCart,
            isConsentGiven,
            hasError: this.hasError,
            isPaymentVerificationRedirection: this.props.data.checkout?.result?.isPaymentVerificationRedirection,
            shouldEnableSinglePaymentAuthorizationCheckout,
            hasSalesOrder:
                this.props.data.checkout &&
                this.props.data.checkout.result !== undefined &&
                this.props.data.checkout.result.salesOrder !== undefined,
            hasInvoiceLine,
            cartStatus: this.cartStatus,
            isMobile,
            backToShoppingUrl,
            editCartLink,
            isEditorialMode: this.isEditorialMode,
            orderConfirmation:
                this.props.slots.orderConfirmation && this.props.slots.orderConfirmation.length > 0
                    ? this.props.slots.orderConfirmation[0]
                    : undefined,
            checkoutProps: { moduleProps: this.props, className: checkoutClass },
            headerProps: { className: 'ms-checkout__head' },
            bodyProps: { className: 'ms-checkout__body' },
            mainProps: { className: 'ms-checkout__main' },
            mainControlProps: { className: 'ms-checkout__main-control' },
            sideProps: { className: hasExpressPaymentContainer ? 'ms-checkout__has-express-side' : 'ms-checkout__side' },
            sideControlFirstProps: { className: 'ms-checkout__side-control-first' },
            sideControlSecondProps: { className: 'ms-checkout__side-control-second' },
            termsAndConditionsProps: { className: 'ms-checkout__terms-and-conditions' },
            title: checkoutHeading && this.renderMsdyn365Text(checkoutHeading),
            checkoutExpressPaymentContainer
        };

        if (!isConsentGiven && isAuthenticated) {
            viewProps = {
                ...viewProps,
                alert: <AlertComponent {...{ message: cookieConsentRequiredMessage }} />
            };
        } else if (this.isLoading()) {
            viewProps = {
                ...viewProps,
                loading: <Waiting className='msc-waiting-circular msc-waiting-lg' />
            };
        } else if (this.hasError) {
            viewProps = {
                ...viewProps,
                alert: <AlertComponent {...{ message: genericErrorMessage }} />
            };
        } else {
            viewProps = {
                ...viewProps,
                alert: errorMessage && <AlertComponent {...{ message: errorMessage }} />,
                canShow: true,
                guidedForm: checkoutInformation ? (
                    <GuidedFormComponent
                        {...{
                            items: checkoutInformation,
                            moduleState,
                            disableGuidedCheckoutFlow,
                            resource: resources,
                            requestContext: this.props.context,
                            isMobile,
                            isEditor: this.isEditorialMode,
                            telemetryContent: this.telemetryContent,
                            isPaymentVerificationRedirection: this.props.data.checkout?.result?.isPaymentVerificationRedirection,
                            shouldEnableSinglePaymentAuthorizationCheckout,
                            hasError: !!errorMessage,
                            hasShippingAddress,
                            hasCartDeliveryMode,
                            hasGuestCheckoutEmail,
                            isTermsAndConditionAccepted,
                            shouldEnableCheckoutErrorDisplayMessaging,
                            shouldFocusOnCheckoutError
                        }}
                    />
                ) : (
                    undefined
                ),
                orderSummary: getOrderSummary(this.props),
                invoicePaymentSummary: getInvoicePaymentSummary(this.props),
                lineItems: hasInvoiceLine ? undefined : getLineItems(this.props, this.telemetryContent),
                placeOrderButton: (
                    <PlaceOrderButtonComponent
                        {...{
                            checkoutBtnText,
                            placeOrder:
                                !isExpressCheckoutApplied && shouldEnableSinglePaymentAuthorizationCheckout
                                    ? this.triggerPaymentWithPlaceOrder
                                    : this.onPlaceOrder,

                            canPlaceOrder: this.canPlaceOrder,
                            telemetryContent: this.telemetryContent,
                            shouldEnableSinglePaymentAuthorizationCheckout: this.props.data.checkout.result
                                ?.shouldEnableSinglePaymentAuthorizationCheckout,
                            isPlaceOrderLoading: this.state.isPlaceOrderLoading,
                            isExpressCheckoutApplied,
                            isPaymentVerificationRedirection
                        }}
                    />
                ),
                termsAndConditions,
                keepShoppingButton: backToShoppingUrl && (
                    <Button
                        className='ms-checkout__btn-keep-shopping msc-btn'
                        title={backToShopping}
                        color='secondary'
                        href={backToShoppingUrl}
                        {...backToShoppingAttributes}
                        disabled={this.state.isPlaceOrderClicked}
                    >
                        {backToShopping}
                    </Button>
                ),
                moduleState,
                telemetryContent: this.telemetryContent,
                checkoutGuidedFormHasError: !!errorMessage
            };
        }

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    @computed public get asyncResultStatus(): AsyncResultStatus | undefined {
        const isLoading = Object.values(this.props.data).some(data => get(data, 'status') === AsyncResultStatusCode.LOADING);
        if (isLoading) {
            return AsyncResultStatusCode.LOADING;
        }

        const isSuccess = Object.values(this.props.data).every(data => get(data, 'status') === AsyncResultStatusCode.SUCCESS);
        if (isSuccess) {
            return AsyncResultStatusCode.SUCCESS;
        }

        const isFailed = Object.values(this.props.data).some(data => get(data, 'status') === AsyncResultStatusCode.FAILED);
        if (isFailed) {
            return AsyncResultStatusCode.FAILED;
        }

        return undefined;
    }

    /**
     * Renders heading.
     * @param checkoutHeading - The checkout heading.
     * @returns React node.
     */
    public renderMsdyn365Text(checkoutHeading: ICheckoutHeadingData): React.ReactNode {
        return (
            <Msdyn365.Text
                {...checkoutHeading}
                tag={checkoutHeading.tag || 'h2'}
                className='ms-checkout__title'
                text={checkoutHeading.text}
                editProps={{ onEdit: this.handleCheckoutHeadingChange, requestContext: this.props.context.request }}
            />
        );
    }

    /**
     * Event handler for heading change event.
     * @param event - The content change event in heading element.
     * @returns The new heading value.
     */
    public handleCheckoutHeadingChange = (event: Msdyn365.ContentEditableEvent) =>
        (this.props.config.checkoutHeading!.text = event.target.value);

    /**
     * Checks if cart is loading.
     * @returns True if is loading, false otherwise.
     */
    private readonly isLoading = (): boolean => {
        return !this.cartStatus || this.cartStatus === 'LOADING' || this.isEmptyCart || !this.state.isValidationPassed;
    };

    /**
     * Get slot items.
     * @param key - The slot key.
     * @returns React node or undefined.
     */
    private readonly getSlotItems = (key: string): React.ReactNode[] | undefined => {
        const { slots } = this.props;
        return slots && slots[key] && slots[key].length > 0 ? slots[key] : undefined;
    };

    /**
     * Trigger the payment section container submit when placing order.
     */
    private readonly triggerPaymentWithPlaceOrder = async (): Promise<void> => {
        this.setState({ isPlaceOrderLoading: true });

        await this.props.data.checkout.result?.updateShouldTriggerPaymentWithPlaceOrder({
            newShouldTriggerPaymentWithPlaceOrder: !this.props.data.checkout.result.shouldTriggerPaymentWithPlaceOrder
        });
    };

    /**
     * On place order.
     * @returns Void promise.
     */
    private readonly onPlaceOrder = async (): Promise<void> => {
        const {
            resources: { checkoutOutOfStockErrorMessage },
            context: {
                actionContext,
                app: {
                    config: { enableStockCheck = false }
                }
            },
            slots: { orderConfirmation },
            data: { checkout, products }
        } = this.props;

        this.props.telemetry.information('Checkout onPlaceOrder is called.');
        this.setState({ isPlaceOrderClicked: true });

        // If hasInvoiceLine is true, no inventory check
        if (
            !this.props.data.checkout.result?.checkoutCart.hasInvoiceLine &&
            enableStockCheck &&
            (await this.isOverMaxQuantity((await checkout).checkoutCart.cart, await products))
        ) {
            this.setState({
                errorMessage: checkoutOutOfStockErrorMessage
            });
            this.props.context.telemetry.error(checkoutOutOfStockErrorMessage);
        } else {
            const hasOrderConfirmation = orderConfirmation && orderConfirmation.length > 0;

            const updatedCartVersion = await this.updateCartLineEmailAddress(this.props.data.checkout.result?.guestCheckoutEmail || '');

            await placeOrder(
                actionContext,
                this.props.data.checkout.result,
                this.props.data.products.result,
                !hasOrderConfirmation,
                updatedCartVersion,
                this.props.data.checkout.result?.isPaymentVerificationRedirection
            ).catch(error => {
                this.handleCheckoutError(error);
            });

            await checkout.result?.updateIsPaymentSectionContainerReady({ newIsPaymentSectionContainerReady: false });
        }
    };

    /**
     * Update receipt email address for electronic cart line.
     * @param newGuestCheckoutEmail - The guest checkout email.
     * @returns The updated cart version.
     */
    private readonly updateCartLineEmailAddress = async (newGuestCheckoutEmail: string): Promise<number | undefined> => {
        const emailDeliveryModeCode = this.props.context.request.channel?.EmailDeliveryModeCode;

        let electronicDeliveryInvoiceAddress: Address;

        const hasShippingAddress = this.props.data.checkout?.result?.hasShippingAddress;

        if (hasShippingAddress && this.props.config.useShippingAddressAsElectronicDeliveryInvoiceAddress) {
            electronicDeliveryInvoiceAddress = this.props.data.checkout?.result?.shippingAddress as Address;
        }

        const emailDeliveryCartLines = this.props.data.checkout.result?.checkoutCart.cart.CartLines?.filter(
            cartLine => cartLine.DeliveryMode && cartLine.DeliveryMode !== '' && cartLine.DeliveryMode === emailDeliveryModeCode
        );

        let updatedCartVersion: number | undefined;
        if (emailDeliveryCartLines && emailDeliveryCartLines.length > 0) {
            const lineDeliverySpecifications: LineDeliverySpecification[] = emailDeliveryCartLines.map(line => {
                return {
                    LineId: line.LineId,
                    DeliverySpecification: {
                        DeliveryModeId: emailDeliveryModeCode,
                        DeliveryPreferenceTypeValue: DeliveryPreferenceType.ElectronicDelivery,
                        ElectronicDeliveryEmailAddress: newGuestCheckoutEmail,
                        DeliveryAddress: hasShippingAddress ? electronicDeliveryInvoiceAddress : undefined
                    }
                };
            });

            await updateLineDeliverySpecificationsAsync(
                { callerContext: this.props.context.actionContext },
                (await this.props.data.checkout).checkoutCart.cart.Id,
                lineDeliverySpecifications
            )
                .then(updatedCart => {
                    updatedCartVersion = updatedCart.Version;
                })
                .catch(error => {
                    this.props.context.actionContext.telemetry.exception(error);
                    throw new Error('[updateLineDeliverySpecificationsAsync] Unable to update electronic delivery email address in cart');
                });
        }

        return updatedCartVersion;
    };

    /**
     * Return true if any product in the cart is over its max quantity.
     * @param cart -- The checkout cart.
     * @param products -- The checkout products.
     * @returns - Is any product in the cart is over max quantity.
     */
    private readonly isOverMaxQuantity = async (cart: Cart, products: SimpleProduct[]): Promise<boolean> => {
        let isOverMaxQuantity = false;
        const emailDeliveryModeCode = this.props.context.request.channel?.EmailDeliveryModeCode;

        await getAvailabilitiesForCartLineItems(
            new ProductAvailabilitiesForCartLineItems(this.props.context.actionContext.requestContext.apiSettings),
            this.props.context.actionContext
        )
            .then(productInventoryInformation => {
                const productsThatShouldValidateInventory: IProductInventoryInformation[] = [];

                cart.CartLines?.map(cartline => {
                    const cartlineProduct = products.find(product => product.RecordId === cartline.ProductId);

                    // If product is non-stocked or cartline is electronic delivery, then no inventory check
                    const isStockedItem = cartlineProduct?.Behavior?.IsStockedProduct;
                    const isEmailDelivery =
                        cartline.DeliveryMode && cartline.DeliveryMode !== '' ? cartline.DeliveryMode === emailDeliveryModeCode : false;
                    const shouldSkipInventoryCheck = !isStockedItem || isEmailDelivery;
                    if (!shouldSkipInventoryCheck && ArrayExtensions.hasElements(productInventoryInformation)) {
                        const foundProductAvailability = productInventoryInformation.find(productInventory => {
                            return productInventory.ProductAvailableQuantity?.ProductId! === cartline.ProductId;
                        });
                        if (foundProductAvailability) {
                            productsThatShouldValidateInventory.push(foundProductAvailability);
                        }
                    }
                });

                const cartLinesInventoryValidation = validateCartLinesInventory(
                    cart.CartLines ?? [],
                    productsThatShouldValidateInventory,
                    this.props.context.actionContext,
                    products,
                    emailDeliveryModeCode
                );

                // If is invalid then exceeds the available quantity
                isOverMaxQuantity = !cartLinesInventoryValidation.isValid;
                return isOverMaxQuantity;
            })
            .catch(error => {
                this.props.context.actionContext.telemetry.exception(error);
                throw new Error('[getAvailabilitiesForCartLineItems] Unable to get availabilities for products in checkout cart');
            });

        return isOverMaxQuantity;
    };

    /**
     * Gets active child in module state.
     * @returns - The module state manager collection.
     */
    private readonly getActiveChildModuleStates = (): IModuleStateManager[] => {
        const { childIds, getModule } = this.props.moduleState;
        return childIds
            .map(getModule)
            .filter((state): state is IModuleStateManager => !!state && !state.isDisabled && state.hasModuleState);
    };

    /**
     * On container ready.
     */
    private readonly onContainerReady = (): void => {
        this.props.telemetry.information('Checkout onContainerReady is called.');

        this.getActiveChildModuleStates().forEach(state => {
            state.isReady && state.onContainerReady && state.onContainerReady();
        });
    };

    /**
     * Redirects to cart page.
     * @param notFoundEditCartLinkMessage - Not found edit cart link message.
     */
    private readonly redirectToCartPage = (notFoundEditCartLinkMessage: string): void => {
        const editCartLink = Msdyn365.getUrlSync('cart', this.props.context.actionContext) || '';
        if (window && editCartLink) {
            window.location.assign(editCartLink);
        } else {
            this.setState({
                errorMessage: this.props.resources.genericErrorMessage
            });
            this.props.context.telemetry.error(notFoundEditCartLinkMessage);
        }
    };

    /**
     * Validates for checkout.
     * @param retry - Retry flag.
     */
    private readonly validateForCheckout = (retry: boolean = true): void => {
        const notFoundEditCartLinkMessage = "Cart doesn't pass validation, but no editCartLink found";
        const cart = this.props.data.checkout.result!.checkoutCart.cart;
        const { Id, Version } = cart;
        if (this._shouldValidateQuantityLimits()) {
            if (Version && Id) {
                validateForCheckoutAsync({ callerContext: this.props.context.actionContext, bypassCache: 'none' }, Id, Version)
                    .then((result: CartLineValidationResults) => {
                        if (result.ValidationFailuresByCartLines?.length !== 0) {
                            this.redirectToCartPage(notFoundEditCartLinkMessage);
                        } else {
                            this.setState({ isValidationPassed: true });
                        }
                    })
                    .catch(error => {
                        this.props.telemetry.warning(error);
                        this.props.telemetry.debug('Unable to validate Cart');
                        if (retry && error.name === 'Microsoft_Dynamics_Commerce_Runtime_InvalidCartVersion') {
                            const cartState = this.props.data.checkout.result?.checkoutCart;
                            cartState
                                ?.refreshCart({})
                                .then(() => {
                                    this.validateForCheckout(false);
                                })
                                .catch((refreshError: Error) => {
                                    this.props.telemetry.warning(refreshError.message);
                                    this.props.telemetry.debug('Unable to refresh Cart');
                                });
                        } else {
                            this.redirectToCartPage(notFoundEditCartLinkMessage);
                        }
                    });
            } else {
                this.redirectToCartPage(notFoundEditCartLinkMessage);
            }
        } else {
            this.setState({ isValidationPassed: true });
        }
    };

    @action
    private readonly _setErrorMessage = (errorMessage: string): void => {
        this.props.telemetry.error(errorMessage);
        this.props.moduleState.setHasError(true);
        this.props.moduleState.onUpdating();
        this.setState({
            errorMessage
        });
    };

    private readonly _shouldValidateQuantityLimits = (): boolean => {
        const featureStatuses = this.props.data.featureState.result;
        const isECommerceQuantityLimitsFeatureEnabledInHq =
            featureStatuses?.find(
                featureState => featureState.Name === 'Dynamics.AX.Application.EcommerceQuantityLimitConfigurationsFeature'
            )?.IsEnabled || false;

        if (isECommerceQuantityLimitsFeatureEnabledInHq) {
            return true;
        }

        const isOrderQuantityLimitsFeatureEnabledInHq =
            featureStatuses?.find(featureState => featureState.Name === 'Dynamics.AX.Application.RetailDefaultOrderQuantityLimitsFeature')
                ?.IsEnabled || false;

        if (!isOrderQuantityLimitsFeatureEnabledInHq) {
            return false;
        }

        const useSiteBuilderSettings = featureStatuses?.find(
            featureState => featureState.Name === 'RevertToSiteBuilderOrderQuantityLimitsSettings'
        )?.IsEnabled;

        if (useSiteBuilderSettings) {
            const defaultOrderQuantityLimitsFeatureConfig = this.props.context?.request?.app?.platform?.enableDefaultOrderQuantityLimits;
            const customerInfo = this.props.data.customerInformation.result;
            const isB2BSite = isChannelTypeB2B(this.props.context.actionContext.requestContext);

            const isOrderQuantityLimitsFeatureEnabledInSiteSettings =
                defaultOrderQuantityLimitsFeatureConfig === 'all' ||
                (customerInfo &&
                    ((defaultOrderQuantityLimitsFeatureConfig === 'b2b' && isB2BSite) ||
                        (defaultOrderQuantityLimitsFeatureConfig === 'b2c' && !isB2BSite)));

            return isOrderQuantityLimitsFeatureEnabledInSiteSettings ?? false;
        } else {
            const cartConfiguration = this.props.data.cartConfiguration?.result;
            return !(cartConfiguration?.IgnoreOrderSettings ?? false);
        }
    };

    /**
     * Save the address as Shipping and Billing address.
     * @param tokenizedPaymentCard - Tokenized payment card.
     */
    private readonly _saveShippingAndBillingAddress = async (tokenizedPaymentCard?: TokenizedPaymentCard): Promise<void> => {
        const checkoutState = this.props.data.checkout.result;

        // For Paypal, the address returned in TokenizedPaymentCard will be used as both shipping and billing address.
        if (checkoutState && tokenizedPaymentCard && tokenizedPaymentCard.Zip) {
            const address: Address = this._getAddressFromTokenizedPaymentCard(tokenizedPaymentCard);

            await checkoutState.updateBillingAddressFromExpressCheckout({ newBillingAddressFromExpressCheckout: address });
            await checkoutState.updateShippingAddressFromExpressCheckout({ newShippingAddressFromExpressCheckout: address });
        }
    };

    /**
     * Get address from tokenizedPaymentCard.
     * @param tokenizedPaymentCard -- The tokenizedPaymentCard from the payment.
     * @returns The address.
     */
    private readonly _getAddressFromTokenizedPaymentCard = (tokenizedPaymentCard: TokenizedPaymentCard): Address => {
        const address: Address = {
            TwoLetterISORegionName: tokenizedPaymentCard.Country,
            Name: tokenizedPaymentCard.NameOnCard,
            Street: tokenizedPaymentCard.Address1,
            StreetNumber: tokenizedPaymentCard.Address2,
            City: tokenizedPaymentCard.City,
            State: tokenizedPaymentCard.State,
            ZipCode: tokenizedPaymentCard.Zip,
            Phone: tokenizedPaymentCard.Phone
        };

        return address;
    };

    /**
     * Handle checkout errors.
     * @param error -- The error on checkout api failure.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    private readonly handleCheckoutError = (error: any) => {
        // Here checkout failure message will be shown if there is any error in checkout api except data validation.
        const {
            resources: {
                genericErrorMessage,
                invalidCartVersionErrorMessage,
                missingRequiredCartTenderLinesErrorMessage,
                checkoutApiFailureErrorMessage,
                invoiceCheckoutApiFailureErrorMessage
            },
            context: { actionContext }
        } = this.props;
        const checkoutResult = this.props.data.checkout.result;
        const apiError = error && error.message;
        if (error?.statusCode === 500) {
            const errorMessage = checkoutApiFailureErrorMessage;
            this.setState({
                errorMessage
            });
            this.props.telemetry.exception(error);
            this.setState({ isPlaceOrderLoading: false });
            return;
        }
        if (checkoutResult && checkoutResult.shouldEnableCheckoutErrorDisplayMessaging) {
            const errorCode = error && error.name ? error.name : '';
            // apiError message will be used if errorcode resource/enums is unavailable
            setCheckoutErrors(errorCode, this.props.resources, !!checkoutResult.isExpressCheckoutApplied, actionContext, apiError);
        } else {
            let errorMessage = genericErrorMessage;
            this.setState({ isPlaceOrderClicked: false });

            if (error && error.name === 'Microsoft_Dynamics_Commerce_Runtime_InvalidCartVersion') {
                errorMessage = invalidCartVersionErrorMessage;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- unknown error type.
            } else if (error && error.name === 'Microsoft_Dynamics_Commerce_Runtime_MissingRequiredCartTenderLines') {
                errorMessage = missingRequiredCartTenderLinesErrorMessage;
            } else if (error && error.name === 'Microsoft_Dynamics_Commerce_Runtime_ExclusiveCouponCannotBeAppliedWithOtherCoupons') {
                // If api error is not available show generic message
                errorMessage = apiError || genericErrorMessage;
            } else {
                if (error.status === ActionErrorStatus.Timeout || error.status === ActionErrorStatus.ServiceUnavailable) {
                    errorMessage = checkoutResult?.checkoutCart.hasInvoiceLine
                        ? invoiceCheckoutApiFailureErrorMessage
                        : checkoutApiFailureErrorMessage;
                }
            }

            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- unknown error type.
            if (
                this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout &&
                error.data?.AdditionalContext &&
                !this.props.data.checkout.result?.isPaymentVerificationRedirection
            ) {
                return;
            }

            this.setState({
                errorMessage
            });
            this.props.telemetry.exception(error);
        }
    };
}

export default Checkout;

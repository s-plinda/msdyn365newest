/*!
 * Copyright (c) Microsoft Corporation.
 * All rights reserved. See LICENSE in the project root for license information.
 */

/* eslint-disable no-duplicate-imports */
import { IModuleStateManager, IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { ArrayExtensions } from '@msdyn365-commerce-modules/retail-actions';
import { IModuleProps, INodeProps } from '@msdyn365-commerce-modules/utilities';
import classname from 'classnames';
import get from 'lodash/get';
import { computed, reaction } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { ICheckoutSectionContainerData } from './checkout-section-container.data';
import { ICheckoutSectionContainerProps } from './checkout-section-container.props.autogenerated';
import LoadingComponent from './components/loading';

/**
 * ICheckoutSectionContainerModuleProps interface.
 */
export interface ICheckoutSectionContainerModuleProps
    extends ICheckoutSectionContainerProps<ICheckoutSectionContainerData>,
        IModuleStateProps {
    enableControl: boolean;
}

interface ICheckoutSectionContainerState {
    isCollapse?: boolean;
}

export interface ICheckoutSectionContainerItem {
    id: string;
    loading?: React.ReactNode;
    itemProps: INodeProps;
    item: React.ReactNode;
}

export interface ICheckoutSectionContainerViewProps extends ICheckoutSectionContainerProps<{}> {
    className: string;
    checkoutPlainContainerProps: IModuleProps;
    items: ICheckoutSectionContainerItem[];
}

const paymentInstrumentModuleId = 'payment-instrument';

const zeroAmount = 0;

/**
 *
 * CheckoutPlainContainer component.
 * @extends {React.Component<ICheckoutSectionContainerModuleProps<ICheckoutSectionContainerData>>}
 */
@observer
export class CheckoutPlainContainer extends React.Component<ICheckoutSectionContainerModuleProps, ICheckoutSectionContainerState> {
    @computed public get amountDue(): number {
        const {
            data: { checkout }
        } = this.props;
        if (!checkout?.result) {
            return 0;
        }

        const checkoutResult = checkout.result;
        const cart = checkoutResult.checkoutCart?.cart;
        if (!cart || !cart.CartLines || !ArrayExtensions.hasElements(cart.CartLines)) {
            return 0;
        }

        return cart.TotalAmount ?? zeroAmount;
    }

    public constructor(props: ICheckoutSectionContainerModuleProps) {
        super(props);
        this.state = { isCollapse: false };
    }

    public componentDidMount(): void {
        const items = this.getItems();
        const childIds = items.map((item: React.ReactNode) => get(item, 'props.id'));
        const shouldEnableSinglePaymentAuthorizationCheckout: boolean =
            this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout ?? false;

        this.props.moduleState.init({
            onEdit: this.onEdit,
            onCancel: shouldEnableSinglePaymentAuthorizationCheckout ? undefined : this.onCancel,
            onSubmit: shouldEnableSinglePaymentAuthorizationCheckout ? undefined : this.onSubmit,
            childIds
        });

        reaction(
            () => this.props.moduleState.isReady,
            () => {
                this.onContainerReady();
            }
        );

        reaction(
            () => this.props.moduleState.shouldSubmitContainer,
            () => {
                this.onSubmit();
            }
        );

        // Reaction to collapse the payment section for new checkout flow.
        reaction(
            () => this.props.data.checkout.result?.shouldCollapsePaymentSection,
            shouldCollapsePaymentSection => {
                const isPaymentSectionContainer = ArrayExtensions.hasElements(
                    this.props.moduleState.childIds.filter(childId => childId.includes(paymentInstrumentModuleId))
                );

                if (shouldEnableSinglePaymentAuthorizationCheckout && isPaymentSectionContainer) {
                    this.setState({ isCollapse: shouldCollapsePaymentSection });
                }
            }
        );

        // Reaction to submit section container for new checkout flow
        reaction(
            () => this.props.data.checkout.result?.shouldTriggerPaymentWithPlaceOrder,
            () => {
                const isPaymentSectionContainer = ArrayExtensions.hasElements(
                    this.props.moduleState.childIds.filter(childId => childId.includes(paymentInstrumentModuleId))
                );

                if (shouldEnableSinglePaymentAuthorizationCheckout && isPaymentSectionContainer) {
                    this.onSubmit();
                }
            }
        );

        // Reaction to set isPaymentSectionContainerReady for new checkout flow.
        reaction(
            () => this.props.moduleState.isReady,
            async isReady => {
                const isPaymentSectionContainer = ArrayExtensions.hasElements(
                    this.props.moduleState.childIds.filter(childId => childId.includes(paymentInstrumentModuleId))
                );

                if (shouldEnableSinglePaymentAuthorizationCheckout && isPaymentSectionContainer && this.amountDue > zeroAmount) {
                    await this.props.data.checkout.result?.updateIsPaymentSectionContainerReady({
                        newIsPaymentSectionContainerReady: isReady
                    });
                }
            }
        );

        // Reaction to set isPaymentSectionContainerHasError for new checkout flow.
        reaction(
            () => this.props.moduleState.hasError,
            async hasError => {
                const isPaymentSectionContainer = ArrayExtensions.hasElements(
                    this.props.moduleState.childIds.filter(childId => childId.includes(paymentInstrumentModuleId))
                );

                if (shouldEnableSinglePaymentAuthorizationCheckout && isPaymentSectionContainer) {
                    await this.props.data.checkout.result?.updateIsPaymentSectionContainerHasError({
                        newIsPaymentSectionContainerHasError: hasError
                    });
                }
            }
        );

        reaction(
            () => this.props.data.checkout.result?.isCheckoutCallFailed,
            async () => {
                const isPaymentSectionContainer = ArrayExtensions.hasElements(
                    this.props.moduleState.childIds.filter(childId => childId.includes(paymentInstrumentModuleId))
                );

                if (isPaymentSectionContainer && this.props.data.checkout.result?.isCheckoutCallFailed) {
                    this.onEdit();
                    await this.props.data.checkout.result.updateIsCheckoutCallFailed({ newIsCheckoutCallFailed: true });
                }
            }
        );
    }

    public componentDidUpdate(): void {
        if (!this.props.moduleState.hasExternalSubmitGroup) {
            return;
        }

        /**
         * Review all modules to updating status if one of the modules has error.
         */
        const { childIds, hasError, getModule } = this.props.moduleState;
        const hasReadyOrSkippedItems = childIds.some((childId: string) => {
            const state = getModule(childId);
            return !!state && (state.isReady || state.isSkipped);
        });
        if (hasReadyOrSkippedItems && hasError) {
            this.onEdit();
        }
    }

    public shouldComponentUpdate(nextProps: ICheckoutSectionContainerModuleProps, nextState: ICheckoutSectionContainerState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        const {
            enableControl,
            moduleState,
            config: { width }
        } = this.props;

        const items = this.getItems();
        if (items.length === 0) {
            this.props.context.telemetry.error('Checkout section content is empty, module wont render');
            return null;
        }

        const moduleClassName = classname(
            'ms-checkout-section-container',
            {
                'has-initialized': moduleState.hasInitialized,
                'is-ready': moduleState.isReady,
                'is-updating': !moduleState.isReady,
                container: width === 'container',
                'col-12 fullwidth': width === 'fluid'
            },
            this.props.config.className
        );

        const viewProps: ICheckoutSectionContainerViewProps = {
            ...this.props,

            className: moduleClassName,
            checkoutPlainContainerProps: {
                moduleProps: this.props,
                className: moduleClassName
            },
            items: items.map((item: React.ReactNode) => {
                const childId = get(item, 'props.id');
                const state = moduleState.getModule(childId);

                // Modules has not completed initializing or it's disable
                const hidden =
                    this.state.isCollapse || (state.hasModuleState && (!state.hasInitialized || state.isDisabled || state.isSkipped));
                return {
                    id: childId,
                    loading: state.hasModuleState && !state.hasInitialized && <LoadingComponent />,
                    itemProps: {
                        'data-type-name': state.typeName,
                        className: classname('ms-checkout-section-container__item', {
                            hidden,
                            initialized: state.hasInitialized,
                            disabled: state.isDisabled,
                            skipped: state.isSkipped,
                            ready: state.isReady,
                            updating: state.isUpdating,
                            pending: state.isPending
                        })
                    },
                    item: React.cloneElement(item as React.ReactElement, { enableControl })
                };
            })
        };
        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private readonly getItems = (): React.ReactNode[] => {
        const { slots } = this.props;
        return (slots && slots.primary && slots.primary.length && slots.primary) || [];
    };

    private readonly getActiveChildModuleStates = (): IModuleStateManager[] => {
        const { childIds, getModule } = this.props.moduleState;
        return childIds
            .map(getModule)
            .filter((state): state is IModuleStateManager => !!state && !state.isDisabled && state.hasModuleState);
    };

    private readonly clearError = (): void => {
        // Clear error before action, otherwise it will rise conflict;
        this.getActiveChildModuleStates().forEach(state => {
            state.hasError && state.setHasError(false);
        });
    };

    private readonly onSubmit = (): void => {
        const isPaymentSectionContainer = ArrayExtensions.hasElements(
            this.props.moduleState.childIds.filter(childId => childId.includes(paymentInstrumentModuleId))
        );

        this.props.telemetry.information('Section container onSubmit is called.');

        this.clearError();
        this.getActiveChildModuleStates().forEach(state => {
            !state.isReady && state.onSubmit && state.onSubmit();
        });

        // Handle when the amount due is zero
        if (
            this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout &&
            isPaymentSectionContainer &&
            this.amountDue === zeroAmount
        ) {
            this.props.data.checkout.result?.updateIsPaymentSectionContainerReady({
                newIsPaymentSectionContainerReady: true
            });
        }
    };

    private readonly onCancel = (): void => {
        this.props.telemetry.information('Section container onCancel is called.');

        this.clearError();
        this.getActiveChildModuleStates().forEach(state => {
            !state.isReady && state.onCancel && state.onCancel();
        });
    };

    private readonly onEdit = (): void => {
        this.props.telemetry.information('Section container onEdit is called.');

        this.getActiveChildModuleStates().forEach(state => {
            (state.isReady || state.isSkipped) && state.onEdit && state.onEdit();
        });
    };

    private readonly onContainerReady = (): void => {
        this.props.telemetry.information('Section container onContainerReady is called.');

        this.getActiveChildModuleStates().forEach(state => {
            state.isReady && state.onContainerReady && state.onContainerReady();
        });
    };
}

export default withModuleState(CheckoutPlainContainer);
